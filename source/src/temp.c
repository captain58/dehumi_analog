#include "temp.h"

#define OUM_K(p1)           ((uint32_t)(p1 * 1000))
#define OUM_M(p1)           (OUM_K(p1) * 1000)
#define HC32_ADC_FULL       (4096)  // adc 满量程
#define HC32_VCC_FULL       (5000)  // 电压满量程

// #define TEMP_OUM            (OUM_K(3.9))  // 温度分压电阻
// #define HUM_OUM_R2             (OUM_K(11))   // 湿度分压电阻
// #define HUM_OUM_R3             (OUM_K(36))   // 湿度分压电阻

#define TEMP_OUM            (OUM_K(10))  // 温度分压电阻
#define HUM_OUM_R2             (OUM_M(1))   // 湿度分压电阻
#define HUM_OUM_R3             (OUM_K(39))   // 湿度分压电阻

#define NTCTEMP_5K3470
// #define NTCTEMP_10K3950
#ifdef NTCTEMP_10K3950
static const uint32_t g_szNtcTempValue[166] = {
345275,
322791,
301925,
282549,
264549,
247816,
232254,
217774,
204292,
191735,
180032,
169120,
158941,
149441,
140571,
132284,
124522,
117266,
110480,
104130,
98185,
92618,
87402,
82513,
77927,
73626,
69588,
65797,
62237,
58890,
55744,
52786,
50002,
47382,
44916,
42592,
40400,
38333,
36385,
34548,
32814,
31179,
29636,
28178,
26800,
25497,
24263,
23096,
21992,
20947,
19958,
19022,
18135,
17294,
16498,
15742,
15025,
14345,
13699,
13086,
12504,
11951,
11426,
10926,
10452,
10000,
9570,
9162,
8773,
8402,
8049,
7713,
7393,
7088,
6797,
6520,
6255,
6003,
5762,
5532,
5313,
5103,
4903,
4711,
4529,
4354,
4187,
4027,
3874,
3728,
3588,
3454,
3326,
3203,
3086,
2973,
2865,
2761,
2662,
2567,
2476,
2388,
2304,
2224,
2146,
2072,
2001,
1932,
1866,
1803,
1742,
1684,
1628,
1574,
1522,
1472,
1424,
1378,
1333,
1290,
1249,
1209,
1171,
1134,
1099,
1065,
1032,
1000,
969,
940,
911,
884,
857,
831,
807,
783,
760,
738,
716,
695,
675,
656,
637,
619,
602,
585,
569,
553,
538,
523,
508,
495,
481,
468,
456,
443,
432,
420,
409,
399,
388,
378,
368,
359,
350,
341};
#endif
#ifdef NTCTEMP_5K3470
static const uint32_t g_szNtcTempValue[291] = {
1050573,
992804,
938572,
887640,
839786,
794807,
752512,
712725,
675282,
640032,
606833,
575554,
546072,
518275,
492055,
467314,
443961,
421910,
401081,
381399,
362794,
345228,
328610,
312884,
297997,
283900,
270546,
257892,
245898,
234527,
223741,
213509,
203799,
194581,
185828,
177514,
169615,
162108,
154972,
148186,
141731,
135511,
129601,
123985,
118645,
113567,
108737,
104141,
99766,
95600,
91633,
87853,
84251,
80817,
77544,
74421,
71442,
68599,
65886,
63295,
60820,
58456,
56197,
54038,
51974,
50000,
48112,
46305,
44576,
42921,
41336,
39819,
38365,
36972,
35637,
34357,
33130,
31953,
30825,
29742,
28702,
27705,
26747,
25827,
24943,
24095,
23279,
22495,
21742,
21017,
20321,
19632,
18969,
18331,
17716,
17123,
16552,
16002,
15471,
14960,
14467,
13992,
13534,
13092,
12665,
12254,
11857,
11475,
11105,
10749,
10405,
10073,
9752,
9442,
9144,
8855,
8576,
8307,
8047,
7795,
7553,
7330,
7115,
6907,
6706,
6512,
6324,
6142,
5967,
5797,
5632,
5473,
5320,
5171,
5027,
4887,
4752,
4621,
4494,
4372,
4253,
4139,
4029,
3922,
3819,
3719,
3622,
3527,
3436,
3347,
3261,
3178,
3097,
3018,
2942,
2868,
2796,
2727,
2659,
2593,
2529,
2468,
2408,
2350,
2294,
2239,
2186,
2134,
2084,
2035,
1988,
1942,
1897,
1853,
1810,
1769,
1729,
1689,
1651,
1614,
1578,
1543,
1508,
1475,
1443,
1411,
1380,
1350,
1321,
1292,
1264,
1238,
1213,
1188,
1164,
1140,
1117,
1094,
1072,
1051,
1030,
1010,
990,
970,
951,
933,
915,
897,
880,
863,
846,
830,
815,
799,
784,
770,
755,
741,
728,
714,
701,
689,
676,
664,
652,
641,
629,
618,
607,
597,
586,
576,
566,
556,
547,
537,
528,
519,
511,
502,
494,
486,
478,
470,
462,
455,
448,
441,
434,
427,
420,
414,
407,
401,
395,
389,
383,
377,
371,
366,
360,
355,
349,
344,
339,
334,
329,
324,
320,
315,
310,
306,
302,
297,
293,
289,
285,
281,
277,
273,
269,
266,
262,
258,
255,
251,
248,
244,
241,
238,
235};
#endif
 
static const float g_szHumValue[18][12] = {
    /*  0               5               10              15              20          25                  30              35              40              45              50              55   温度 */
    {1282.373322,	942.031174,	    678.1911114,	552.8089417,	460.289414,	    375.1822181,	278.325385,	    212.9337588,	165.3862667,	127.1066986,	98.05780488,	75.16218176},/* 10 湿度 */
    {1177.605974,	866.9618758,	622.3002852,	504.6612976,	416.8693835,	338.8441561,	252.3480772,	192.7524913,	150.3141966,	115.3453258,	89.12509381,	68.23386941},/* 15 */
    {1062.36189,    784.3856477,	560.8203763,	451.698889,	    369.1073499,	298.8722879,	223.7730387,	170.5530971,	133.7349195,	102.4078156,	79.29911164,	60.61272584},/* 20 */
    {968.0712764,	716.8232793,	510.5186326,	408.3660093,	330.0293224,	266.1680321,	200.3934617,	152.3899563,	120.1700564,	91.82258008,	71.25967167,	54.37724473},/* 25 */
    {826.6353559,	615.4797267,	435.0660172,	343.3666897,	271.4122812,	217.1116484,	165.3240963,	125.1452452,	99.8227618,	    75.94472674,	59.20051173,	45.02402306},/* 30 */
    {656.9122512,	493.8674636,	344.5228786,	265.3675062,	201.0718317,	158.243988,	    123.2408577,	92.45159187,	75.40600826,	56.89130272,	44.72951979,	33.80015706},/* 35 */
    {463.8800775,	353.0153668,	243.8352261,	182.1555593,	138.8125689,	109.867317,	    86.58144726,	63.72525283,	51.07516489,	39.33211163,	30.941445,	    23.79195043},/* 40 */
    {337.2873087,	260.615355,	    177.827941,	    127.6438809,	98.1747943,	    78.34296428,	62.66138647,	44.97798549,	35.15604405,	27.86121169,	21.92804935,	17.25837892},/* 45 */
    {188.5307692,	146.2307692,	93.30769231,	70.71461538,	54.66923077,	43.21538462,	33.15384615,	24.36923077,	19.5,           15.04615385,	12.44769231,	9.967692308},/* 50 */
    {109.9005839,	75.33555637,	52.96634439,	40.73802778,	30.76096815,	25.00345362,	18.87991349,	13.83566379,	10.88930093,	8.729713684,	7.177942913,	6.067363296},/* 55 */
    {62.86923077,	40.44615385,	30.28,          23.24846154,	17.50769231,	14.18461538,	10.87692308,	8.655384615,	6.961538462,	5.6,	        4.72,           3.920769231},/* 60 */
    {34.43499308,	22.90867653,	17.29816359,	12.8528666,	    10.13911386,	8.649679188,	6.8706844,	    5.457578611,	4.405548635,	3.664375746,	3.147748314,	2.636331386},/* 65 */
    {19.36153846,	14.24461538,	11.00076923,	8.566153846,	6.685384615,	5.693846154,	4.495384615,	3.723846154,	3.068461538,	2.580769231,	2.203846154,	1.878461538},/* 70 */
    {11.88502227,	9.099132726,	6.576578374,	5.345643594,	4.419230769,	3.801893963,	3.140508694,	2.588212915,	2.187761624,	1.849268619,	1.592208727,	1.367728826},/* 75 */
    {7.478461538,	5.867692308,	4.571538462,	3.724615385,	3.040769231,	2.611538462,	2.176153846,	1.840769231,	1.582307692,	1.361538462,	1.172307692,	1.023076923},/* 80 */
    {4.698941086,	3.76703799,	    2.985382619,	2.483133105,	2.116923077,	1.819700859,	1.570362804,	1.321295634,	1.135010816,	0.986279486,	0.88511561,	    0.776247117},/* 85 */
    {3.3419504,     2.707692308,	2.183846154,	1.832307692,	1.531538462,	1.372307692,	1.150800389,	1.009230769,	0.870769231,	0.759769231,	0.672230769,	0.592846154},/* 90 */
    {2.413076923,	2.085384615,	1.668461538,	1.35,           1.113846154,	0.997461538,	0.881076923,	0.774615385,	0.670938462,	0.590769231,	0.5106,         0.46344692},/* 95 */
};

static uint64_t g_szTempArr[18] = {0};

int16_t GetTempFromAdc(uint32_t uiTemp) {
    float fVer = 0;
    uint32_t uiOum;
    int index;
    int idot;
    int iTemp;

    fVer = (float)uiTemp * HC32_VCC_FULL / HC32_ADC_FULL;
    uiOum = (uint32_t)(HC32_VCC_FULL * TEMP_OUM / fVer) - TEMP_OUM;

    #ifdef NTCTEMP_5K3470
    uiOum *= 10;
    #endif

    for (index = 0; index < sizeof(g_szNtcTempValue); index++) {
        if (g_szNtcTempValue[index] <= uiOum)
            break;
    }

    if (index == 0) {
        return -4000;
    }

    idot = (uiOum - g_szNtcTempValue[index]) * 100 / (g_szNtcTempValue[index-1] - g_szNtcTempValue[index]);
    iTemp = (index - 40) * 100 - idot;
    return iTemp;
}

uint16_t GetHumFromAdc(int16_t iTemp, uint32_t uiHum) {
    int64_t uiM;       /* 中间系数 */
    uint64_t uiOum;     /* 阻值 */
    uint16_t uiHumRes;  /* 湿度（乘100） */
    uint16_t uiTempIndex = 0;
    uint16_t uiTempdot = 0;
    int i;

    /* adc值为0，返回0 */
    if (uiHum == 0) {
        Debug_Print(">>>GetHumFromAdc failed! uihum is 0\n");
        return 0;
    }

    /* 温度不在测试范围内，返回0 */
    if ((iTemp < 0) || (iTemp > 5500)) {
        Debug_Print(">>>GetHumFromAdc failed! iTemp err\n");
        return 0;
    }

    /* 构建该温度下的阻值表 */
    memset(g_szTempArr, 0, sizeof(g_szTempArr));
    uiTempIndex = iTemp / 500;
    uiTempdot = iTemp % 500;
    for (i = 0; i < 18; i++) {
        if (uiTempIndex >= 11) {
            g_szTempArr[i] = (uint64_t)(g_szHumValue[i][11] * 1000);
        } else {
            g_szTempArr[i] = (uint64_t)(g_szHumValue[i][uiTempIndex] * 1000) - (uint64_t)((g_szHumValue[i][uiTempIndex] - g_szHumValue[i][uiTempIndex+1]) * 1000) * uiTempdot / 500;
        }
        // Debug_Print(">>>GetHumFromAdc: g_szTempArr %d:%llu\n", i, g_szTempArr[i]);
    }

    uiM = (HC32_ADC_FULL * HUM_OUM_R3) / uiHum - HUM_OUM_R3;
    uiOum =  uiM * HUM_OUM_R2 / (HUM_OUM_R2 - uiM); 

    // Debug_Print(">>>GetHumFromAdc: uiOum value :%llu\n", uiOum);
    
    /* 根据新的温度表获取湿度 */
    for (i = 0; i < 18; i++) {
        if (g_szTempArr[i] > uiOum) {
            continue;
        }

        if (i == 0) {
            if (g_szTempArr[0] < uiOum) {
                Debug_Print(">>>GetHumFromAdc: g_szTempArr[0] value :%llu, uiOum value : %llu\n", g_szTempArr[0], uiOum);
                return 0;
            } else {
                return 1000;
            }
        }

        uiHumRes = 1000 + i * 500 - (uiOum - g_szTempArr[i]) * 500 / (g_szTempArr[i-1] - g_szTempArr[i]);
        return uiHumRes;
    }

    Debug_Print(">>>GetHumFromAdc: not find\n");
    return 0;
}

boolean_t Sync_TempHum(int16_t *pitemp, uint16_t *puiHum) {
    uint32_t uiTemp = 0;
    uint32_t uiHum = 0;
    uint32_t szTemp[5];
    uint32_t szHum[5];
    uint16_t i = 0;
    uint16_t j = 0;
    uint16_t uiHum_tmp = 0;

    while (1) {
        IoDevSetRH_IO1(1);
        IoDevSetRH_IO2(0);
        delay10us(45);
        uiHum += Bsp_Adc_GetAdc(BSP_ADC_HUMP_CHANAL);
        delay10us(2);
        IoDevSetRH_IO1(0);
        IoDevSetRH_IO2(1);
        delay10us(25);
        uiTemp += Bsp_Adc_GetAdc(BSP_ADC_TEMP_CHANAL);
        delay10us(21);
        i++;
        if (i >= 30) {
            szTemp[j] = uiTemp / 30;
            szHum[j] = uiHum / 30;
            j++;
            if (j >= 5) {
                IoDevSetRH_IO1(0);
                IoDevSetRH_IO2(0);
                uiTemp = (szTemp[1] + szTemp[2] + szTemp[3] + szTemp[4]) / 4;
                uiHum = (szHum[1] + szHum[2] + szHum[3] + szHum[4]) / 4;
                break;
            }
            i = 0;
            uiTemp = 0;
            uiHum = 0;
        }
    }
    
    Debug_Print(">>>Sync_TempHum: adc value temp:%u, humi:%u\n", uiTemp, uiHum);

    if (uiTemp == 0) {
        return FALSE;
    }

    

    *pitemp = GetTempFromAdc(uiTemp);

    if (*pitemp < -3900) {
        Debug_Print(">>>GetTempFromAdc failed! temp:%d\n", *pitemp);
        return FALSE;
    }

    
    uiHum_tmp = GetHumFromAdc(*pitemp, uiHum);
    if(0 != uiHum_tmp)
    {
        if(uiHum_tmp < 1500) 
        {
            
            Debug_Print(">>>Sync_TempHum: humi src %d correct to:2000\n", uiHum);
            uiHum_tmp = 1500;
        }
        *puiHum = uiHum_tmp;
    }
    else
    {
        Debug_Print(">>>Sync_TempHum: can't calculate , maintain old value \n");
    }
    
//	    if(uiHum >= 4096)
//	    {
//	        Debug_Print(">>>Sync_TempHum: humi src %d correct to:9500\n", uiHum);
//	        uiHum = 9500;
//	    }
//	    else
//	    {
//	        uiHum = GetHumFromAdc(*pitemp, uiHum);
//	        
//	        if(uiHum < 1500) 
//	        {
//	            
//	            Debug_Print(">>>Sync_TempHum: humi src %d correct to:2000\n", uiHum);
//	            uiHum = 1500;
//	        }
//	        
//	    }
//	    *puiHum  = uiHum;
    Debug_Print(">>>Sync_TempHum: temp:%d, humi:%u\n", *pitemp, *puiHum);
    return TRUE;
}

/*
while(1)
{
    CLRIO2();
    SETIO1();
    DelayXus(250);
    GETADCH += GetADCResult(CHRH);//湿度 ADC 值
    DelayXus(210);//减去大概的 AD 采样时间
    CLRIO1();
    SETIO2();
    DelayXus(250);
    GETADCT += GetADCResult(CHRT);//温度 ADC 采样
    DelayXus(210);
    if((++i)>=30)//一次采样 30 个周期
    {
        AvgTem[k] = GETADCT/30;
        AvgHum[k] = GETADCH/30;
        if((++k)>=5)
        {
            CLRIO2();//让 IO1 与 IO2 同时置为低电平，减小直流时间段
            CLRIO1();
            //由于开始一次采样误差较大，去掉 AvgTem[0]
            SumTem = AvgTem[1]+AvgTem[2]+AvgTem[3]+AvgTem[4];
            SumTem = SumTem/4;
            SumHum = AvgHum[1]+AvgHum[2]+AvgHum[3]+AvgHum[4];
            SumHum = SumHum/4;
            ResultTem = GetTemp(SumTem);//得到温度
            //通过函数查表得到对应湿度值
            //可以将阻值全部转化成对应 AD 值，通过快速查表，省去很大的内存空间
            ResultHu = Tansfom(SumHum,ResultTem);
            - 9 -
            *Hum = (uint)ResultHu;
            *tem = (int)ResultTem;
            break;//退出
        }
        GETADCH = 0;
        GETADCT = 0;
        i=0;
    }
}

*/
